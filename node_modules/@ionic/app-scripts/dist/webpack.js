"use strict";
var logger_1 = require('./util/logger');
var helpers_1 = require('./util/helpers');
var events_1 = require('./util/events');
var config_1 = require('./util/config');
var path_1 = require('path');
var webpackApi = require('webpack');
var fs_extra_1 = require('fs-extra');
var events_2 = require('events');
var eventEmitter = new events_2.EventEmitter();
var INCREMENTAL_BUILD_FAILED = 'incremental_build_failed';
var INCREMENTAL_BUILD_SUCCESS = 'incremental_build_success';
function webpack(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    var logger = new logger_1.Logger('webpack');
    return webpackWorker(context, configFile)
        .then(function () {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.webpack = webpack;
function webpackUpdate(event, path, context, configFile) {
    var logger = new logger_1.Logger('webpack update');
    var files = updateFile(context.fileChanged, context.tsFiles);
    var webpackConfig = getWebpackConfig(context, configFile);
    return writeFilesToDisk(files, context)
        .then(function () {
        logger_1.Logger.debug('Wrote updated file to disk');
        return runWebpackIncrementalBuild(false, webpackConfig);
    }).then(function (stats) {
        logger_1.Logger.debug('Incremental Build Done');
        return webpackBuildComplete(stats, context, webpackConfig);
    }).then(function () {
        return logger.finish();
    }).catch(function (err) {
        throw logger.fail(err);
    });
}
exports.webpackUpdate = webpackUpdate;
function webpackWorker(context, configFile) {
    var webpackConfig = getWebpackConfig(context, configFile);
    // in order to use watch mode, we need to write the
    // transpiled files to disk, so go ahead and do that
    var files = createFileList(context.tsFiles);
    return writeFilesToDisk(files, context)
        .then(function () {
        logger_1.Logger.debug('Wrote .js files to disk');
        if (context.isProd) {
            return runWebpackFullBuild(webpackConfig);
        }
        else {
            return runWebpackIncrementalBuild(true, webpackConfig);
        }
    }).then(function (stats) {
        return webpackBuildComplete(stats, context, webpackConfig);
    });
}
exports.webpackWorker = webpackWorker;
function webpackBuildComplete(stats, context, webpackConfig) {
    // set the module files used in this bundle
    // this reference can be used elsewhere in the build (sass)
    var files = stats.compilation.modules.map(function (webpackObj) {
        if (webpackObj.resource) {
            return webpackObj.resource;
        }
        else {
            return webpackObj.context;
        }
    }).filter(function (path) {
        // just make sure the path is not null
        return path && path.length > 0;
    });
    context.moduleFiles = files;
    // async cache all the module paths so we don't need
    // to always bundle to know which modules are used
    helpers_1.setModulePathsCache(context.moduleFiles);
    events_1.emit(events_1.EventType.FileChange, getOutputDest(context, webpackConfig));
    return Promise.resolve();
}
function runWebpackFullBuild(config) {
    return new Promise(function (resolve, reject) {
        var callback = function (err, stats) {
            if (err) {
                reject(new logger_1.BuildError(err));
            }
            else {
                resolve(stats);
            }
        };
        var compiler = webpackApi(config);
        compiler.run(callback);
    });
}
function runWebpackIncrementalBuild(initializeWatch, config) {
    return new Promise(function (resolve, reject) {
        // start listening for events, remove listeners once an event is received
        eventEmitter.on(INCREMENTAL_BUILD_FAILED, function (err) {
            eventEmitter.removeAllListeners();
            reject(new logger_1.BuildError(err));
        });
        eventEmitter.on(INCREMENTAL_BUILD_SUCCESS, function (stats) {
            eventEmitter.removeAllListeners();
            resolve(stats);
        });
        if (initializeWatch) {
            startWebpackWatch(config);
        }
    });
}
function startWebpackWatch(config) {
    var compiler = webpackApi(config);
    compiler.watch({}, function (err, stats) {
        if (err) {
            eventEmitter.emit(INCREMENTAL_BUILD_FAILED, err);
        }
        else {
            eventEmitter.emit(INCREMENTAL_BUILD_SUCCESS, stats);
        }
    });
}
function getWebpackConfig(context, configFile) {
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    var webpackConfig = config_1.fillConfigDefaults(configFile, taskInfo.defaultConfigFile);
    webpackConfig.entry = config_1.replacePathVars(context, webpackConfig.entry);
    webpackConfig.output.path = config_1.replacePathVars(context, webpackConfig.output.path);
    return webpackConfig;
}
exports.getWebpackConfig = getWebpackConfig;
function getOutputDest(context, webpackConfig) {
    return path_1.join(webpackConfig.output.path, webpackConfig.output.filename);
}
exports.getOutputDest = getOutputDest;
function writeFilesToDisk(files, context) {
    var promises = [];
    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
        var file = files_1[_i];
        var filePath = transformPath(file.input, context);
        promises.push(writeIndividualFile(filePath, file.output, file.map));
    }
    return Promise.all(promises);
}
function writeIndividualFile(filePath, content, sourcemap) {
    return ensureDirectoriesExist(filePath)
        .then(function () {
        return Promise.all([
            helpers_1.writeFileAsync(filePath, content),
            helpers_1.writeFileAsync(filePath + '.map', sourcemap)
        ]);
    });
}
function transformPath(originalPath, context) {
    var tmpPath = originalPath.replace(context.srcDir, context.tmpDir);
    var fileName = path_1.basename(tmpPath, '.ts');
    return path_1.join(path_1.dirname(tmpPath), fileName + '.js');
}
function ensureDirectoriesExist(path) {
    return new Promise(function (resolve, reject) {
        var directoryName = path_1.dirname(path);
        fs_extra_1.mkdirs(directoryName, function (err) {
            if (err) {
                reject(new logger_1.BuildError(err));
            }
            else {
                resolve();
            }
        });
    });
}
function createFileList(tsFiles) {
    var files = [];
    for (var key in tsFiles) {
        var file = tsFiles[key];
        file.input = key;
        files.push(file);
    }
    return files;
}
function updateFile(fileChangedPath, tsFiles) {
    var files = [];
    var file = tsFiles[fileChangedPath];
    file.input = fileChangedPath;
    files.push(file);
    return files;
}
var taskInfo = {
    fullArgConfig: '--webpack',
    shortArgConfig: '-w',
    envConfig: 'ionic_webpack',
    defaultConfigFile: 'webpack.config'
};
